package database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.List;
import javax.sql.DataSource;
import org.apache.commons.lang3.StringUtils;


public abstract class AbstractMapper <T,K> {
	protected DataSource ds;
	/**
	 * Devuelve el nombre de la tabla 
	 * @return String
	 */
	protected abstract String getTableName();
	/**
	 * Devuelve los nombres de las columnas de una tabla 
	 * @return Array Strings
	 */
	protected abstract String[] getColumnNames();
	protected abstract T buildObject (ResultSet rs) throws SQLException;

	protected abstract Object[] serializeKey(K key);
	protected abstract Object[] serializeObject(T object);
	
	
	/**
	 * Devuelve el nombre de las keys de una tabla
	 * @return Array Strings
	 */
	protected abstract String[] getKeyColumnNames();
	protected abstract K getKey(T obj);
	public AbstractMapper(DataSource dataSource){
		this.ds=dataSource;
	}
	
	public DataSource getDs() {
		return ds;
	}
	public void setDs(DataSource ds) {
		this.ds = ds;
	}

	/**
	 * Genera las condiciones where de una consulta a ra√≠z de una serie de condiciones que se le han pasado previamente
	 * @param conditions
	 * @return String
	 */
	private String generateWhereConditions(QueryConditions[] conditions) {
		
		String result=" where ";
		String[] cadConditions=new String[conditions.length];
		for (int i = 0; i < conditions.length; i++) {
			cadConditions[i]=conditions[i].toString();
		}
		result+=StringUtils.join(cadConditions, " and ");
		return result;
	}
	private List<T> findByConditions(QueryConditions[] conditions) {
		// TODO Auto-generated method stub
		List<T> result= new LinkedList<T>();
		for (int i = 0; i < conditions.length; i++) {
			
		}
		return null;
	}
	/**
	 * Genera 
	 * @param id
	 * @return QueryConditions
	 */
	private QueryConditions[] getQueryConditionsFromKey(K id){
		String[] keyColumnNames= getKeyColumnNames();
		Object[] keyValues= serializeKey(id);
		QueryConditions[] conditions= new QueryConditions[keyColumnNames.length];
		for (int i = 0; i < conditions.length; i++) {
			conditions[i]= new QueryConditions(keyColumnNames[i], Operator.EQ, keyValues[i]);
		}
		return conditions;
	}
	
	//-------------Genericas, sirven para todos los mappers
	public T findById(K id){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		T result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			QueryConditions[] conditions= getQueryConditionsFromKey(id);//Creamos condicion con id
			
			String whereConditions=generateWhereConditions(conditions);//String with 'where conditions'
			
			String sql="SELECT "+ " * "+" From "+getTableName() + whereConditions;//String with SQL statement, FALTABA EL "From table"
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			for (int i = 0; i < conditions.length; i++) {
				pst.setObject(i+1,conditions[i].getValor());
			}
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			if(rs.next()){
				
				result = buildObject(rs);
			}
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		
		
		return result;
	}
	
	/**
	 * Modifica un objeto de la BBDD
	 * @param obj
	 */
	public  void update(T obj) {//T obj
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
					//UPDATE table_name SET column1=value1,column2=value2,...WHERE some_column=some_value;
			
			sql =  " update " + getTableName()+" set "+pharseUpdate();// +" where " +getKeyColumnNames()+ "= ? ";
	
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			//rellenar las ? , una funcion que reciba un statement pst y un objeto obj y las rellene TODAS
			fill(pst,obj,false);
			
			
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
			//String updateString =  "update " + dbName + ".COFFEES " +   "set SALES = ? where COF_NAME = ?";				   			  
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
	}
	/**
	 * Inserta un objeto nuevo en la BBDD
	 * @param obj
	 */
	public  void Insert(T obj) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
			
				//sql =InsertStat(obj);//String with SQL statement
			sql = "Insert into "+getTableName()+pharseInsert();
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			//rellenar las ? , una funcion que reciba un statement pst y un objeto obj y las rellene TODAS
			fill(pst,obj,true);
			
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
	}
	
	/**
	 * Se le pasa una id y se ocupa de borar dicho columna de la tabla correspondiente de la BBDD	
	 * @param id
	 */
	public void Delete(K id) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			
			QueryConditions[] conditions= getQueryConditionsFromKey(id);//Creamos condicion con id	
			String whereConditions=generateWhereConditions(conditions);//String with 'where conditions'

			
			//String sql="Delete from "+ getTableName()+ " where "+pharseDelete(id);//String with SQL statement
			String sql="Delete from "+ getTableName()+ whereConditions;
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			for (int i = 0; i < conditions.length; i++) {//leemos las condiciones para hacer el delete, es decir que lea la id que vaya a borrar
				pst.setObject(i+1,conditions[i].getValor());
			}
			
			rs = pst.executeUpdate();//Executes the SQL statement in this PreparedStatement object, 
									//which must be an SQL Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE; 
			
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		
	}
	//---------------------
	
	//-----abstrarctas (se implementan dentro de cada mapper que hereda)
	/**
	 * El statement y un objeto, rellena ? del statment con los atributos del objeto.
	 * @param pst
	 * @param obj
	 * @param ins , true si es insert false si es update
	 */
	protected abstract void fill(PreparedStatement pst , T obj,boolean ins);
	/**
	 * Devuelve la estructura en un String, de un update con las ? por rellenar 
	 * @return String
	 */
	protected abstract String pharseUpdate();
	
	/**
	 * String para parsear las consultas tipo insert, devuelve (col1,col2...) VALUES(value1,value2...) 
	 * @param obj
	 * @return String
	 */
	protected abstract String  pharseInsert();
	
	//---------------------
	
	//Ejemplos de consultas mysql
	//DELETE FROM tabla_relacionada WHERE columna_relacionada IN (registros_seleccionados);
	//UPDATE table_name SET column1=value1,column2=value2,...WHERE some_column=some_value;	
	//INSERT INTO table_name (col1,col2) VALUES(15,col1*2);
}
