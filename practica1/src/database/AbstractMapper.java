package database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.List;
import javax.sql.DataSource;
import org.apache.commons.lang3.StringUtils;


public abstract class AbstractMapper <T,K> {
	protected DataSource ds;
	protected abstract String getTableName();
	protected abstract String[] getColumnNames();
	protected abstract T buildObject (ResultSet rs) throws SQLException;

	protected abstract Object[] serializeKey(K key);
	protected abstract Object[] serializeObject(T object);
	protected abstract K getKey(T obj);
	public AbstractMapper(DataSource dataSource){
		this.ds=dataSource;
	}
	
	public DataSource getDs() {
		return ds;
	}
	public void setDs(DataSource ds) {
		this.ds = ds;
	}

	private String generateWhereConditions(QueryConditions[] conditions) {
		// TODO Auto-generated method stub
		String result="Where ";
		String[] cadConditions=new String[conditions.length];
		for (int i = 0; i < conditions.length; i++) {
			cadConditions[i]=conditions[i].toString();
		}
		result+=StringUtils.join(cadConditions, " and ");
		return result;
	}
	private List<T> findByConditions(QueryConditions[] conditions) {
		// TODO Auto-generated method stub
		List<T> result= new LinkedList<T>();
		for (int i = 0; i < conditions.length; i++) {
			
		}
		return null;
	}
	private QueryConditions[] getQueryConditionsFromKey(K id){
		String[] keyColumnNames= getColumnNames();
		Object[] keyValues= serializeKey(id);
		QueryConditions[] conditions= new QueryConditions[keyColumnNames.length];
		for (int i = 0; i < conditions.length; i++) {
			conditions[i]= new QueryConditions(keyColumnNames[i], Operator.EQ, keyValues[i]);
		}
		return conditions;
	}
	
	//-------------Genericas, sirven para todos los mappers
	public T findById(K id){
		/*QueryConditions[] conditions= getQueryConditionsFromKey(id);
		List<T> results = findByConditions(conditions);
		if(results.isEmpty()){
			return null;
		}
		else{
			return results.get(0);
		}*/
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		T result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			QueryConditions[] conditions= getQueryConditionsFromKey(id);
			
			String whereConditions=generateWhereConditions(conditions);//String with 'where conditions'
			
			String sql="SELECT"+ getColumnNames()+" From "+getTableName() + whereConditions;//String with SQL statement, FALTABA EL "From table"
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			for (int i = 0; i < conditions.length; i++) {
				pst.setObject(i+1,conditions[i].getValor());
			}
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			if(rs!=null){
				result = buildObject(rs);
			}
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		
		
		return result;
	}
	
	
	/**
	 * Modifica un objeto de la BBDD
	 * @param obj
	 */
	public  void update(T obj) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
			
			sql= UpdateStat(obj);
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
	}
	/**
	 * Inserta un objeto nuevo en la BBDD
	 * @param obj
	 */
	public  void Insert(T obj) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
			
				sql =InsertStat(obj);//String with SQL statement
			
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
	}
	
	/**
	 * Se le pasa una id y se ocupa de borar dicho columna de la tabla correspondiente de la BBDD	
	 * @param id
	 */
	public void Delete(K id) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			
			
			String sql="Delete from "+ getTableName()+ " where "+pharseDelete(id);//String with SQL statement
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs = pst. executeUpdate();//Executes the SQL statement in this PreparedStatement object, 
									//which must be an SQL Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE; 
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		
	}
	//---------------------
	
	//--------Privadas(estas en concreto se podrÃ­a prescindir, aportan claridad a las genericas)	
	private String UpdateStat(T obj){
		return "Update "+getTableName()+" Set "+pharseUpdate(obj);
	}
	private String InsertStat(T obj){
		return "Insert into "+getTableName()+pharseInsert(obj);
	}
	
	//-----abstrarctas (se implementan dentro de cada mapper que hereda)
	/**
	 * String para paremtrizar las consultas de tipo update, devuelve colun=value...where "id"=value_id
	 * Nota: el nick no se puede modificar porque es nuestra clave.
	 * @param obj
	 * @return String
	 */
	public abstract String pharseUpdate(T obj);
	
	/**
	 * String para parsear las consultas tipo insert, devuelve (col1,col2...) VALUES(value1,value2...) 
	 * @param obj
	 * @return String
	 */
	public abstract String pharseInsert(T obj);
	/**
	 * String para parsear las consultas tipo Delete, devuelve id = value_id
	 * @param id
	 * @return
	 */
	public abstract String pharseDelete(K id);
	//---------------------
	
	//Ejemplos de consultas mysql
	//DELETE FROM tabla_relacionada WHERE columna_relacionada IN (registros_seleccionados);
	//UPDATE table_name SET column1=value1,column2=value2,...WHERE some_column=some_value;	
	//INSERT INTO table_name (col1,col2) VALUES(15,col1*2);
}
